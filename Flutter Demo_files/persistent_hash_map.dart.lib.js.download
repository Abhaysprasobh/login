// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.3 (stable) (Tue Mar 26 14:21:33 2024 +0000) on "windows_x64"
// Module: packages/flutter/src/foundation/persistent_hash_map.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk'], (function load__packages__flutter__src__foundation__persistent_hash_map_dart(dart_sdk) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  var persistent_hash_map = Object.create(dart.library);
  var $hashCode = dartx.hashCode;
  var $tripleShift = dartx['>>>'];
  var $_get = dartx._get;
  var $_set = dartx._set;
  var $leftShift = dartx['<<'];
  var $length = dartx.length;
  var $rightShift = dartx['>>'];
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T = {
    _TrieNodeN: () => (T._TrieNodeN = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_TrieNode?")))(),
    intAndintToint: () => (T.intAndintToint = dart.constFn(dart_rti.findType("core|int(core|int,core|int)")))(),
    int: () => (T.int = dart.constFn(dart_rti.findType("core|int")))(),
    intAndObjectAndint__To_TrieNode: () => (T.intAndObjectAndint__To_TrieNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_TrieNode(core|int,core|Object,core|int,core|Object?)")))(),
    intAndObjectAndintToObjectN: () => (T.intAndObjectAndintToObjectN = dart.constFn(dart_rti.findType("core|Object?(core|int,core|Object,core|int)")))(),
    ListOfObjectN: () => (T.ListOfObjectN = dart.constFn(dart_rti.findType("core|List<core|Object?>")))(),
    _TrieNode: () => (T._TrieNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_TrieNode")))(),
    intAndintAnd_TrieNodeTo_CompressedNode: () => (T.intAndintAnd_TrieNodeTo_CompressedNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_CompressedNode(core|int,core|int,flutter__src__foundation__persistent_hash_map|_TrieNode)")))(),
    intTo_FullNode: () => (T.intTo_FullNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_FullNode(core|int)")))(),
    intToint: () => (T.intToint = dart.constFn(dart_rti.findType("core|int(core|int)")))(),
    intAndObjectAndObjectN__To_TrieNode: () => (T.intAndObjectAndObjectN__To_TrieNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_TrieNode(core|int,core|Object,core|Object?,core|Object,core|int,core|Object?)")))(),
    _CompressedNode: () => (T._CompressedNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_CompressedNode")))(),
    intAndObjectAndObjectN__To_HashCollisionNode: () => (T.intAndObjectAndObjectN__To_HashCollisionNode = dart.constFn(dart_rti.findType("flutter__src__foundation__persistent_hash_map|_HashCollisionNode(core|int,core|Object,core|Object?,core|Object,core|Object?)")))(),
    ObjectToint: () => (T.ObjectToint = dart.constFn(dart_rti.findType("core|int(core|Object)")))(),
    ObjectN: () => (T.ObjectN = dart.constFn(dart_rti.findType("core|Object?")))()
  };
  var G = {
    ListOfObjectN: () => (G.ListOfObjectN = dart.constFn(core.List$(T.ObjectN())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  var I = [
    "package:flutter/src/foundation/persistent_hash_map.dart",
    "dart:core",
    "file:///C:/src/flutter/packages/flutter/lib/src/foundation/persistent_hash_map.dart"
  ];
  var _root$ = dart.privateName(persistent_hash_map, "PersistentHashMap._root");
  var _eval = dart.privateName(dart_rti, "_eval");
  var _bind = dart.privateName(dart_rti, "_bind");
  var _root = dart.privateName(persistent_hash_map, "_root");
  var _as = dart.privateName(dart_rti, "_as");
  const _is_PersistentHashMap_default = Symbol('_is_PersistentHashMap_default');
  persistent_hash_map.PersistentHashMap$ = dart.generic((K, V) => {
    var __t$PersistentHashMapOfK$V = () => (__t$PersistentHashMapOfK$V = dart.constFn(K[_eval]("@<0>")[_bind](V)[_eval]("flutter__src__foundation__persistent_hash_map|PersistentHashMap<1,2>")))();
    var __t$ObjectNAndObjectNToPersistentHashMapOfK$V = () => (__t$ObjectNAndObjectNToPersistentHashMapOfK$V = dart.constFn(K[_eval]("@<0>")[_bind](V)[_eval]("flutter__src__foundation__persistent_hash_map|PersistentHashMap<1,2>(core|Object?,core|Object?)")))();
    var __t$VN = () => (__t$VN = dart.constFn(V[_eval]("0?")))();
    var __t$ObjectNToVN = () => (__t$ObjectNToVN = dart.constFn(V[_eval]("0?(core|Object?)")))();
    var __t$PersistentHashMapOfK$V$ = () => (__t$PersistentHashMapOfK$V$ = dart.constFn(persistent_hash_map.PersistentHashMap$(K, V)))();
    class PersistentHashMap extends core.Object {
      get [_root]() {
        return this[_root$];
      }
      set [_root](value) {
        super[_root] = value;
      }
      static ['_#empty#tearOff'](K, V) {
        return new (persistent_hash_map.PersistentHashMap$(K, V)).empty();
      }
      static ['_#_#tearOff'](K, V, _root) {
        return new (persistent_hash_map.PersistentHashMap$(K, V)).__(_root);
      }
      put(key, value) {
        let t$360;
        K[_as](key);
        V[_as](value);
        let newRoot = (t$360 = this[_root], t$360 == null ? persistent_hash_map._CompressedNode.empty : t$360).put(0, key, dart.hashCode(key), value);
        if (dart.equals(newRoot, this[_root])) {
          return this;
        }
        return new (__t$PersistentHashMapOfK$V$()).__(newRoot);
      }
      _get(key) {
        K[_as](key);
        if (this[_root] == null) {
          return null;
        }
        return __t$VN()[_as](this[_root].get(0, key, dart.hashCode(key)));
      }
    }
    (PersistentHashMap.empty = function() {
      PersistentHashMap.__.call(this, null);
    }).prototype = PersistentHashMap.prototype;
    (PersistentHashMap.__ = function(_root) {
      this[_root$] = _root;
      this.$ti = this.$ti || __t$PersistentHashMapOfK$V();
      ;
    }).prototype = PersistentHashMap.prototype;
    dart.addTypeTests(PersistentHashMap);
    PersistentHashMap.prototype[_is_PersistentHashMap_default] = true;
    dart.addRtiResources(PersistentHashMap, ["flutter__src__foundation__persistent_hash_map|PersistentHashMap"]);
    dart.addTypeCaches(PersistentHashMap);
    dart.setMethodSignature(PersistentHashMap, () => dart.global.Object.setPrototypeOf({
      put: __t$ObjectNAndObjectNToPersistentHashMapOfK$V(),
      _get: __t$ObjectNToVN()
    }, dart.getMethods(dart.global.Object.getPrototypeOf(PersistentHashMap))));
    dart.setLibraryUri(PersistentHashMap, I[0]);
    dart.setFieldSignature(PersistentHashMap, () => dart.global.Object.setPrototypeOf({[_root]: {type: T._TrieNodeN(), isConst: false, isFinal: true, libraryUri: I[0]}}, dart.getFields(dart.global.Object.getPrototypeOf(PersistentHashMap))));
    return PersistentHashMap;
  });
  persistent_hash_map.PersistentHashMap = persistent_hash_map.PersistentHashMap$();
  dart.addTypeTests(persistent_hash_map.PersistentHashMap, _is_PersistentHashMap_default);
  persistent_hash_map._TrieNode = class _TrieNode extends core.Object {
    static trieIndex(hash, bitIndex) {
      return (hash[$tripleShift](bitIndex) & 31) >>> 0;
    }
  };
  (persistent_hash_map._TrieNode.new = function() {
    ;
  }).prototype = persistent_hash_map._TrieNode.prototype;
  dart.addTypeTests(persistent_hash_map._TrieNode);
  dart.addRtiResources(persistent_hash_map._TrieNode, ["flutter__src__foundation__persistent_hash_map|_TrieNode"]);
  dart.addTypeCaches(persistent_hash_map._TrieNode);
  dart.setStaticMethodSignature(persistent_hash_map._TrieNode, () => ['trieIndex']);
  dart.setLibraryUri(persistent_hash_map._TrieNode, I[0]);
  dart.setStaticFieldSignature(persistent_hash_map._TrieNode, () => ['hashBitsPerLevel', 'hashBitsPerLevelMask']);
  dart.defineLazy(persistent_hash_map._TrieNode, {
    /*persistent_hash_map._TrieNode.hashBitsPerLevel*/get hashBitsPerLevel() {
      return 5;
    },
    /*persistent_hash_map._TrieNode.hashBitsPerLevelMask*/get hashBitsPerLevelMask() {
      return 31;
    }
  }, false);
  persistent_hash_map._FullNode = class _FullNode extends persistent_hash_map._TrieNode {
    static ['_#new#tearOff'](descendants) {
      return new persistent_hash_map._FullNode.new(descendants);
    }
    put(bitIndex, key, keyHash, value) {
      let t$360, t$360$;
      let index = persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex);
      let node = (t$360 = persistent_hash_map._unsafeCast(T._TrieNodeN(), this.descendants[$_get](index)), t$360 == null ? persistent_hash_map._CompressedNode.empty : t$360);
      let newNode = node.put(bitIndex + 5, key, keyHash, value);
      return newNode === node ? this : new persistent_hash_map._FullNode.new((t$360$ = persistent_hash_map._copy(this.descendants), (() => {
        t$360$[$_set](index, newNode);
        return t$360$;
      })()));
    }
    get(bitIndex, key, keyHash) {
      let t$360;
      let index = persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex);
      let node = persistent_hash_map._unsafeCast(T._TrieNodeN(), this.descendants[$_get](index));
      t$360 = node;
      return t$360 == null ? null : t$360.get(bitIndex + 5, key, keyHash);
    }
  };
  (persistent_hash_map._FullNode.new = function(descendants) {
    this.descendants = descendants;
    ;
  }).prototype = persistent_hash_map._FullNode.prototype;
  dart.addTypeTests(persistent_hash_map._FullNode);
  dart.addRtiResources(persistent_hash_map._FullNode, ["flutter__src__foundation__persistent_hash_map|_FullNode"]);
  dart.addTypeCaches(persistent_hash_map._FullNode);
  dart.setMethodSignature(persistent_hash_map._FullNode, () => dart.global.Object.setPrototypeOf({
    put: T.intAndObjectAndint__To_TrieNode(),
    get: T.intAndObjectAndintToObjectN()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(persistent_hash_map._FullNode))));
  dart.setLibraryUri(persistent_hash_map._FullNode, I[0]);
  dart.setFieldSignature(persistent_hash_map._FullNode, () => dart.global.Object.setPrototypeOf({descendants: {type: T.ListOfObjectN(), isConst: false, isFinal: true, libraryUri: I[1]}}, dart.getFields(dart.global.Object.getPrototypeOf(persistent_hash_map._FullNode))));
  dart.setStaticFieldSignature(persistent_hash_map._FullNode, () => ['numElements']);
  dart.defineLazy(persistent_hash_map._FullNode, {
    /*persistent_hash_map._FullNode.numElements*/get numElements() {
      return 32;
    }
  }, false);
  var _compressedIndex = dart.privateName(persistent_hash_map, "_compressedIndex");
  var _inflate = dart.privateName(persistent_hash_map, "_inflate");
  persistent_hash_map._CompressedNode = class _CompressedNode extends persistent_hash_map._TrieNode {
    static ['_#new#tearOff'](occupiedIndices, keyValuePairs) {
      return new persistent_hash_map._CompressedNode.new(occupiedIndices, keyValuePairs);
    }
    static ['_#_empty#tearOff']() {
      return new persistent_hash_map._CompressedNode._empty();
    }
    static single(bitIndex, keyHash, node) {
      let t$360;
      let bit = (1)[$leftShift](persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex));
      let keyValuePairs = (t$360 = persistent_hash_map._makeArray(2), (() => {
        t$360[$_set](1, node);
        return t$360;
      })());
      return new persistent_hash_map._CompressedNode.new(bit, keyValuePairs);
    }
    static ['_#single#tearOff'](bitIndex, keyHash, node) {
      return persistent_hash_map._CompressedNode.single(bitIndex, keyHash, node);
    }
    put(bitIndex, key, keyHash, value) {
      let t$360, t$360$, t$360$0, t$360$1;
      let bit = (1)[$leftShift](persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex));
      let index = this[_compressedIndex](bit);
      if ((this.occupiedIndices & bit) !== 0) {
        let keyOrNull = this.keyValuePairs[$_get](2 * index);
        let valueOrNode = this.keyValuePairs[$_get](2 * index + 1);
        if (keyOrNull == null) {
          let newNode = persistent_hash_map._unsafeCast(T._TrieNode(), valueOrNode).put(bitIndex + 5, key, keyHash, value);
          if (dart.equals(newNode, valueOrNode)) {
            return this;
          }
          return new persistent_hash_map._CompressedNode.new(this.occupiedIndices, (t$360 = persistent_hash_map._copy(this.keyValuePairs), (() => {
            t$360[$_set](2 * index + 1, newNode);
            return t$360;
          })()));
        }
        if (dart.equals(key, keyOrNull)) {
          return core.identical(value, valueOrNode) ? this : new persistent_hash_map._CompressedNode.new(this.occupiedIndices, (t$360$ = persistent_hash_map._copy(this.keyValuePairs), (() => {
            t$360$[$_set](2 * index + 1, value);
            return t$360$;
          })()));
        }
        let newNode = persistent_hash_map._CompressedNode._resolveCollision(bitIndex + 5, keyOrNull, valueOrNode, key, keyHash, value);
        return new persistent_hash_map._CompressedNode.new(this.occupiedIndices, (t$360$0 = persistent_hash_map._copy(this.keyValuePairs), (() => {
          t$360$0[$_set](2 * index, null);
          t$360$0[$_set](2 * index + 1, newNode);
          return t$360$0;
        })()));
      } else {
        let occupiedCount = persistent_hash_map._bitCount(this.occupiedIndices);
        if (occupiedCount >= 16) {
          t$360$1 = this[_inflate](bitIndex);
          return (() => {
            t$360$1.descendants[$_set](persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex), persistent_hash_map._CompressedNode.empty.put(bitIndex + 5, key, keyHash, value));
            return t$360$1;
          })();
        } else {
          let prefixLength = 2 * index;
          let totalLength = 2 * occupiedCount;
          let newKeyValuePairs = persistent_hash_map._makeArray(totalLength + 2);
          for (let srcIndex = 0; srcIndex < prefixLength; srcIndex = srcIndex + 1) {
            newKeyValuePairs[$_set](srcIndex, this.keyValuePairs[$_get](srcIndex));
          }
          newKeyValuePairs[$_set](prefixLength, key);
          newKeyValuePairs[$_set](prefixLength + 1, value);
          for (let srcIndex = prefixLength, dstIndex = prefixLength + 2; srcIndex < totalLength; srcIndex = srcIndex + 1, dstIndex = dstIndex + 1) {
            newKeyValuePairs[$_set](dstIndex, this.keyValuePairs[$_get](srcIndex));
          }
          return new persistent_hash_map._CompressedNode.new((this.occupiedIndices | bit) >>> 0, newKeyValuePairs);
        }
      }
    }
    get(bitIndex, key, keyHash) {
      let bit = (1)[$leftShift](persistent_hash_map._TrieNode.trieIndex(keyHash, bitIndex));
      if ((this.occupiedIndices & bit) === 0) {
        return null;
      }
      let index = this[_compressedIndex](bit);
      let keyOrNull = this.keyValuePairs[$_get](2 * index);
      let valueOrNode = this.keyValuePairs[$_get](2 * index + 1);
      if (keyOrNull == null) {
        let node = persistent_hash_map._unsafeCast(T._TrieNode(), valueOrNode);
        return node.get(bitIndex + 5, key, keyHash);
      }
      if (dart.equals(key, keyOrNull)) {
        return valueOrNode;
      }
      return null;
    }
    [_inflate](bitIndex) {
      let nodes = persistent_hash_map._makeArray(32);
      let srcIndex = 0;
      for (let dstIndex = 0; dstIndex < 32; dstIndex = dstIndex + 1) {
        if ((this.occupiedIndices[$tripleShift](dstIndex) & 1) !== 0) {
          let keyOrNull = this.keyValuePairs[$_get](srcIndex);
          if (keyOrNull == null) {
            nodes[$_set](dstIndex, this.keyValuePairs[$_get](srcIndex + 1));
          } else {
            nodes[$_set](dstIndex, persistent_hash_map._CompressedNode.empty.put(bitIndex + 5, keyOrNull, dart.hashCode(this.keyValuePairs[$_get](srcIndex)), this.keyValuePairs[$_get](srcIndex + 1)));
          }
          srcIndex = srcIndex + 2;
        }
      }
      return new persistent_hash_map._FullNode.new(nodes);
    }
    [_compressedIndex](bit) {
      return persistent_hash_map._bitCount((this.occupiedIndices & bit - 1) >>> 0);
    }
    static _resolveCollision(bitIndex, existingKey, existingValue, key, keyHash, value) {
      let existingKeyHash = dart.hashCode(existingKey);
      return existingKeyHash === keyHash ? persistent_hash_map._HashCollisionNode.fromCollision(keyHash, existingKey, existingValue, key, value) : persistent_hash_map._CompressedNode.empty.put(bitIndex, existingKey, existingKeyHash, existingValue).put(bitIndex, key, keyHash, value);
    }
  };
  (persistent_hash_map._CompressedNode.new = function(occupiedIndices, keyValuePairs) {
    this.occupiedIndices = occupiedIndices;
    this.keyValuePairs = keyValuePairs;
    ;
  }).prototype = persistent_hash_map._CompressedNode.prototype;
  (persistent_hash_map._CompressedNode._empty = function() {
    persistent_hash_map._CompressedNode.new.call(this, 0, persistent_hash_map._CompressedNode._emptyArray);
  }).prototype = persistent_hash_map._CompressedNode.prototype;
  dart.addTypeTests(persistent_hash_map._CompressedNode);
  dart.addRtiResources(persistent_hash_map._CompressedNode, ["flutter__src__foundation__persistent_hash_map|_CompressedNode"]);
  dart.addTypeCaches(persistent_hash_map._CompressedNode);
  dart.setMethodSignature(persistent_hash_map._CompressedNode, () => dart.global.Object.setPrototypeOf({
    put: T.intAndObjectAndint__To_TrieNode(),
    get: T.intAndObjectAndintToObjectN(),
    [_inflate]: T.intTo_FullNode(),
    [_compressedIndex]: T.intToint()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(persistent_hash_map._CompressedNode))));
  dart.setStaticMethodSignature(persistent_hash_map._CompressedNode, () => ['single', '_resolveCollision']);
  dart.setLibraryUri(persistent_hash_map._CompressedNode, I[0]);
  dart.setFieldSignature(persistent_hash_map._CompressedNode, () => dart.global.Object.setPrototypeOf({
    occupiedIndices: {type: T.int(), isConst: false, isFinal: true, libraryUri: I[1]},
    keyValuePairs: {type: T.ListOfObjectN(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(persistent_hash_map._CompressedNode))));
  dart.setStaticFieldSignature(persistent_hash_map._CompressedNode, () => ['empty', '_emptyArray']);
  dart.defineLazy(persistent_hash_map._CompressedNode, {
    /*persistent_hash_map._CompressedNode.empty*/get empty() {
      return new persistent_hash_map._CompressedNode._empty();
    },
    /*persistent_hash_map._CompressedNode._emptyArray*/get _emptyArray() {
      return persistent_hash_map._makeArray(0);
    }
  }, false);
  var _indexOf = dart.privateName(persistent_hash_map, "_indexOf");
  persistent_hash_map._HashCollisionNode = class _HashCollisionNode extends persistent_hash_map._TrieNode {
    static ['_#new#tearOff'](hash, keyValuePairs) {
      return new persistent_hash_map._HashCollisionNode.new(hash, keyValuePairs);
    }
    static fromCollision(keyHash, keyA, valueA, keyB, valueB) {
      let list = persistent_hash_map._makeArray(4);
      list[$_set](0, keyA);
      list[$_set](1, valueA);
      list[$_set](2, keyB);
      list[$_set](3, valueB);
      return new persistent_hash_map._HashCollisionNode.new(keyHash, list);
    }
    static ['_#fromCollision#tearOff'](keyHash, keyA, valueA, keyB, valueB) {
      return persistent_hash_map._HashCollisionNode.fromCollision(keyHash, keyA, valueA, keyB, valueB);
    }
    put(bitIndex, key, keyHash, val) {
      let t$360;
      if (keyHash === this.hash) {
        let index = this[_indexOf](key);
        if (index !== -1) {
          return core.identical(this.keyValuePairs[$_get](index + 1), val) ? this : new persistent_hash_map._HashCollisionNode.new(keyHash, (t$360 = persistent_hash_map._copy(this.keyValuePairs), (() => {
            t$360[$_set](index + 1, val);
            return t$360;
          })()));
        }
        let length = this.keyValuePairs[$length];
        let newArray = persistent_hash_map._makeArray(length + 2);
        for (let i = 0; i < length; i = i + 1) {
          newArray[$_set](i, this.keyValuePairs[$_get](i));
        }
        newArray[$_set](length, key);
        newArray[$_set](length + 1, val);
        return new persistent_hash_map._HashCollisionNode.new(keyHash, newArray);
      }
      return persistent_hash_map._CompressedNode.single(bitIndex, this.hash, this).put(bitIndex, key, keyHash, val);
    }
    get(bitIndex, key, keyHash) {
      let index = this[_indexOf](key);
      return index < 0 ? null : this.keyValuePairs[$_get](index + 1);
    }
    [_indexOf](key) {
      let length = this.keyValuePairs[$length];
      for (let i = 0; i < length; i = i + 2) {
        if (dart.equals(key, this.keyValuePairs[$_get](i))) {
          return i;
        }
      }
      return -1;
    }
  };
  (persistent_hash_map._HashCollisionNode.new = function(hash, keyValuePairs) {
    this.hash = hash;
    this.keyValuePairs = keyValuePairs;
    ;
  }).prototype = persistent_hash_map._HashCollisionNode.prototype;
  dart.addTypeTests(persistent_hash_map._HashCollisionNode);
  dart.addRtiResources(persistent_hash_map._HashCollisionNode, ["flutter__src__foundation__persistent_hash_map|_HashCollisionNode"]);
  dart.addTypeCaches(persistent_hash_map._HashCollisionNode);
  dart.setMethodSignature(persistent_hash_map._HashCollisionNode, () => dart.global.Object.setPrototypeOf({
    put: T.intAndObjectAndint__To_TrieNode(),
    get: T.intAndObjectAndintToObjectN(),
    [_indexOf]: T.ObjectToint()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(persistent_hash_map._HashCollisionNode))));
  dart.setStaticMethodSignature(persistent_hash_map._HashCollisionNode, () => ['fromCollision']);
  dart.setLibraryUri(persistent_hash_map._HashCollisionNode, I[0]);
  dart.setFieldSignature(persistent_hash_map._HashCollisionNode, () => dart.global.Object.setPrototypeOf({
    hash: {type: T.int(), isConst: false, isFinal: true, libraryUri: I[1]},
    keyValuePairs: {type: T.ListOfObjectN(), isConst: false, isFinal: true, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(persistent_hash_map._HashCollisionNode))));
  persistent_hash_map._bitCount = function _bitCount(n) {
    if (!((n & 4294967295) >>> 0 === n)) dart.assertFailed(null, I[2], 357, 10, "(n & 0xFFFFFFFF) == n");
    n = n - (n[$rightShift](1) & 1431655765);
    n = (n & 858993459) + (n >>> 2 & 858993459);
    n = n + n[$rightShift](4) & 252645135;
    n = n + n[$rightShift](8);
    n = n + n[$rightShift](16);
    return n & 63;
  };
  persistent_hash_map._copy = function _copy(array) {
    let clone = persistent_hash_map._makeArray(array[$length]);
    for (let j = 0; j < array[$length]; j = j + 1) {
      clone[$_set](j, array[$_get](j));
    }
    return clone;
  };
  persistent_hash_map._makeArray = function _makeArray(length) {
    return G.ListOfObjectN().filled(length, null);
  };
  persistent_hash_map._unsafeCast = function _unsafeCast(T, o) {
    return T[_as](o);
  };
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"flutter__src__foundation__persistent_hash_map|PersistentHashMap":{"PersistentHashMap.K":"1","PersistentHashMap.V":"2"},"core|int":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|num":{"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|Comparable":{"Comparable.T":"1"},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"flutter__src__foundation__persistent_hash_map|_CompressedNode":{"flutter__src__foundation__persistent_hash_map|_TrieNode":[]},"flutter__src__foundation__persistent_hash_map|_FullNode":{"flutter__src__foundation__persistent_hash_map|_TrieNode":[]},"flutter__src__foundation__persistent_hash_map|_HashCollisionNode":{"flutter__src__foundation__persistent_hash_map|_TrieNode":[]}}'));
  dart.trackLibraries("packages/flutter/src/foundation/persistent_hash_map.dart", {
    "package:flutter/src/foundation/persistent_hash_map.dart": persistent_hash_map
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["persistent_hash_map.dart"],"names":[],"mappings":"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","file":"../../../../../../../../F:/packages/flutter/src/foundation/persistent_hash_map.dart.lib.js"}');
  // Exports:
  return {
    src__foundation__persistent_hash_map: persistent_hash_map
  };
}));

//# sourceMappingURL=persistent_hash_map.dart.lib.js.map

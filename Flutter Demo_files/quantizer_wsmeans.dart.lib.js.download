// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.3.3 (stable) (Tue Mar 26 14:21:33 2024 +0000) on "windows_x64"
// Module: packages/material_color_utilities/quantize/quantizer_wsmeans.dart
// Flags: newRuntimeTypes(true), soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/material_color_utilities/quantize/src/point_provider_lab.dart', 'packages/material_color_utilities/quantize/quantizer.dart'], (function load__packages__material_color_utilities__quantize__quantizer_wsmeans_dart(dart_sdk, packages__material_color_utilities__quantize__src__point_provider_lab$46dart, packages__material_color_utilities__quantize__quantizer$46dart) {
  'use strict';
  const dart_rti = dart_sdk.dart_rti;
  const core = dart_sdk.core;
  const _js_helper = dart_sdk._js_helper;
  const _interceptors = dart_sdk._interceptors;
  const math = dart_sdk.math;
  const collection = dart_sdk.collection;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const point_provider_lab = packages__material_color_utilities__quantize__src__point_provider_lab$46dart.quantize__src__point_provider_lab;
  const quantizer = packages__material_color_utilities__quantize__quantizer$46dart.quantize__quantizer;
  var quantizer_wsmeans = Object.create(dart.library);
  var $compareTo = dartx.compareTo;
  var $update = dartx.update;
  var $add = dartx.add;
  var $forEach = dartx.forEach;
  var $_get = dartx._get;
  var $_set = dartx._set;
  var $map = dartx.map;
  var $toList = dartx.toList;
  var $length = dartx.length;
  var $contains = dartx.contains;
  var $modulo = dartx['%'];
  var $sort = dartx.sort;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(true);
  var T = {
    DistanceAndIndex: () => (T.DistanceAndIndex = dart.constFn(dart_rti.findType("material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex")))(),
    ObjectNToint: () => (T.ObjectNToint = dart.constFn(dart_rti.findType("core|int(core|Object?)")))(),
    double: () => (T.double = dart.constFn(dart_rti.findType("core|double")))(),
    int: () => (T.int = dart.constFn(dart_rti.findType("core|int")))(),
    ListOfdouble: () => (T.ListOfdouble = dart.constFn(dart_rti.findType("core|List<core|double>")))(),
    intToint: () => (T.intToint = dart.constFn(dart_rti.findType("core|int(core|int)")))(),
    VoidToint: () => (T.VoidToint = dart.constFn(dart_rti.findType("core|int()")))(),
    intTovoid: () => (T.intTovoid = dart.constFn(dart_rti.findType("~(core|int)")))(),
    intToListOfdouble: () => (T.intToListOfdouble = dart.constFn(dart_rti.findType("core|List<core|double>(core|int)")))(),
    ListOfint: () => (T.ListOfint = dart.constFn(dart_rti.findType("core|List<core|int>")))(),
    intToListOfint: () => (T.intToListOfint = dart.constFn(dart_rti.findType("core|List<core|int>(core|int)")))(),
    ListOfDistanceAndIndex: () => (T.ListOfDistanceAndIndex = dart.constFn(dart_rti.findType("core|List<material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex>")))(),
    intToDistanceAndIndex: () => (T.intToDistanceAndIndex = dart.constFn(dart_rti.findType("material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex(core|int)")))(),
    intToListOfDistanceAndIndex: () => (T.intToListOfDistanceAndIndex = dart.constFn(dart_rti.findType("core|List<material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex>(core|int)")))(),
    StringTovoid: () => (T.StringTovoid = dart.constFn(dart_rti.findType("~(core|String)")))(),
    IterableOfintAndint__ToQuantizerResult: () => (T.IterableOfintAndint__ToQuantizerResult = dart.constFn(dart_rti.findType("material_color_utilities__quantize__quantizer|QuantizerResult(core|Iterable<core|int>,core|int{maxIterations:core|int,pointProvider:material_color_utilities__quantize__src__point_provider|PointProvider,returnInputPixelToClusterPixel:core|bool,startingClusters:core|List<core|int>})")))(),
    bool: () => (T.bool = dart.constFn(dart_rti.findType("core|bool")))()
  };
  var G = {
    IdentityMapOfint$int: () => (G.IdentityMapOfint$int = dart.constFn(_js_helper.IdentityMap$(T.int(), T.int())))(),
    JSArrayOfListOfdouble: () => (G.JSArrayOfListOfdouble = dart.constFn(_interceptors.JSArray$(T.ListOfdouble())))(),
    JSArrayOfint: () => (G.JSArrayOfint = dart.constFn(_interceptors.JSArray$(T.int())))(),
    ListOfint: () => (G.ListOfint = dart.constFn(core.List$(T.int())))(),
    ListOfListOfint: () => (G.ListOfListOfint = dart.constFn(core.List$(T.ListOfint())))(),
    ListOfListOfDistanceAndIndex: () => (G.ListOfListOfDistanceAndIndex = dart.constFn(core.List$(T.ListOfDistanceAndIndex())))(),
    ListOfDistanceAndIndex: () => (G.ListOfDistanceAndIndex = dart.constFn(core.List$(T.DistanceAndIndex())))(),
    ListOfdouble: () => (G.ListOfdouble = dart.constFn(core.List$(T.double())))(),
    JSArrayOfdouble: () => (G.JSArrayOfdouble = dart.constFn(_interceptors.JSArray$(T.double())))(),
    LinkedHashMapOfint$int: () => (G.LinkedHashMapOfint$int = dart.constFn(collection.LinkedHashMap$(T.int(), T.int())))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  dart.defineLazy(CT, {
    get C0() {
      return C[0] = dart.constList([], T.int());
    },
    get C1() {
      return C[1] = dart.const(Object.setPrototypeOf({
      }, point_provider_lab.PointProviderLab.prototype));
    }
  }, false);
  var C = Array(2).fill(void 0);
  var I = [
    "package:material_color_utilities/quantize/quantizer_wsmeans.dart",
    "dart:core"
  ];
  var distance$ = dart.privateName(quantizer_wsmeans, "DistanceAndIndex.distance");
  var index$ = dart.privateName(quantizer_wsmeans, "DistanceAndIndex.index");
  var _as = dart.privateName(dart_rti, "_as");
  quantizer_wsmeans.DistanceAndIndex = class DistanceAndIndex extends core.Object {
    get distance() {
      return this[distance$];
    }
    set distance(value) {
      this[distance$] = value;
    }
    get index() {
      return this[index$];
    }
    set index(value) {
      this[index$] = value;
    }
    static ['_#new#tearOff'](distance, index) {
      return new quantizer_wsmeans.DistanceAndIndex.new(distance, index);
    }
    compareTo(other) {
      T.DistanceAndIndex()[_as](other);
      if (this.distance < other.distance) {
        return -1;
      } else if (this.distance > other.distance) {
        return 1;
      } else {
        return 0;
      }
    }
  };
  (quantizer_wsmeans.DistanceAndIndex.new = function(distance, index) {
    this[distance$] = distance;
    this[index$] = index;
    ;
  }).prototype = quantizer_wsmeans.DistanceAndIndex.prototype;
  dart.addTypeTests(quantizer_wsmeans.DistanceAndIndex);
  dart.addRtiResources(quantizer_wsmeans.DistanceAndIndex, ["material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex", "core|Comparable"]);
  dart.addTypeCaches(quantizer_wsmeans.DistanceAndIndex);
  dart.setMethodSignature(quantizer_wsmeans.DistanceAndIndex, () => dart.global.Object.setPrototypeOf({
    compareTo: T.ObjectNToint(),
    [$compareTo]: T.ObjectNToint()
  }, dart.getMethods(dart.global.Object.getPrototypeOf(quantizer_wsmeans.DistanceAndIndex))));
  dart.setLibraryUri(quantizer_wsmeans.DistanceAndIndex, I[0]);
  dart.setFieldSignature(quantizer_wsmeans.DistanceAndIndex, () => dart.global.Object.setPrototypeOf({
    distance: {type: T.double(), isConst: false, isFinal: false, libraryUri: I[1]},
    index: {type: T.int(), isConst: false, isFinal: false, libraryUri: I[1]}
  }, dart.getFields(dart.global.Object.getPrototypeOf(quantizer_wsmeans.DistanceAndIndex))));
  dart.defineExtensionMethods(quantizer_wsmeans.DistanceAndIndex, ['compareTo']);
  quantizer_wsmeans.QuantizerWsmeans = class QuantizerWsmeans extends core.Object {
    static debugLog(log) {
      ;
    }
    static quantize(inputPixels, maxColors, opts) {
      let t$360;
      let startingClusters = opts && 'startingClusters' in opts ? opts.startingClusters : C[0] || CT.C0;
      let pointProvider = opts && 'pointProvider' in opts ? opts.pointProvider : C[1] || CT.C1;
      let maxIterations = opts && 'maxIterations' in opts ? opts.maxIterations : 5;
      let returnInputPixelToClusterPixel = opts && 'returnInputPixelToClusterPixel' in opts ? opts.returnInputPixelToClusterPixel : false;
      let pixelToCount = new (G.IdentityMapOfint$int()).new();
      let points = G.JSArrayOfListOfdouble().of([]);
      let pixels = G.JSArrayOfint().of([]);
      let pointCount = 0;
      inputPixels[$forEach](dart.fn(inputPixel => {
        let pixelCount = pixelToCount[$update](inputPixel, dart.fn(value => value + 1, T.intToint()), {ifAbsent: dart.fn(() => 1, T.VoidToint())});
        if (pixelCount === 1) {
          pointCount = pointCount + 1;
          points[$add](pointProvider.fromInt(inputPixel));
          pixels[$add](inputPixel);
        }
      }, T.intTovoid()));
      let counts = G.ListOfint().filled(pointCount, 0);
      for (let i = 0; i < pointCount; i = i + 1) {
        let pixel = pixels[$_get](i);
        let count = dart.nullCheck(pixelToCount[$_get](pixel));
        counts[$_set](i, count);
      }
      let clusterCount = math.min(T.int(), maxColors, pointCount);
      let clusters = startingClusters[$map](T.ListOfdouble(), dart.fn(e => pointProvider.fromInt(e), T.intToListOfdouble()))[$toList]();
      let additionalClustersNeeded = clusterCount - clusters[$length];
      if (additionalClustersNeeded > 0) {
        let random = math.Random.new(272008);
        let indices = G.JSArrayOfint().of([]);
        for (let i = 0; i < additionalClustersNeeded; i = i + 1) {
          let index = random.nextInt(points[$length]);
          while (indices[$contains](index)) {
            index = random.nextInt(points[$length]);
          }
          indices[$add](index);
        }
        indices[$forEach](dart.fn(index => {
          clusters[$add](points[$_get](index));
        }, T.intTovoid()));
      }
      quantizer_wsmeans.QuantizerWsmeans.debugLog("have " + dart.strSafe(clusters[$length]) + " starting clusters, " + dart.strSafe(points[$length]) + " points");
      let clusterIndices = G.ListOfint().generate(pointCount, dart.fn(index => index[$modulo](clusterCount), T.intToint()));
      let indexMatrix = G.ListOfListOfint().generate(clusterCount, dart.fn(_ => G.ListOfint().filled(clusterCount, 0), T.intToListOfint()));
      let distanceToIndexMatrix = G.ListOfListOfDistanceAndIndex().generate(clusterCount, dart.fn(index => G.ListOfDistanceAndIndex().generate(clusterCount, dart.fn(index => new quantizer_wsmeans.DistanceAndIndex.new(0.0, index), T.intToDistanceAndIndex())), T.intToListOfDistanceAndIndex()));
      let pixelCountSums = G.ListOfint().filled(clusterCount, 0);
      for (let iteration = 0; iteration < maxIterations; iteration = iteration + 1) {
        ;
        let pointsMoved = 0;
        for (let i = 0; i < clusterCount; i = i + 1) {
          for (let j = i + 1; j < clusterCount; j = j + 1) {
            let distance = pointProvider.distance(clusters[$_get](i), clusters[$_get](j));
            distanceToIndexMatrix[$_get](j)[$_get](i).distance = distance;
            distanceToIndexMatrix[$_get](j)[$_get](i).index = i;
            distanceToIndexMatrix[$_get](i)[$_get](j).distance = distance;
            distanceToIndexMatrix[$_get](i)[$_get](j).index = j;
          }
          distanceToIndexMatrix[$_get](i)[$sort]();
          for (let j = 0; j < clusterCount; j = j + 1) {
            indexMatrix[$_get](i)[$_set](j, distanceToIndexMatrix[$_get](i)[$_get](j).index);
          }
        }
        for (let i = 0; i < pointCount; i = i + 1) {
          let point = points[$_get](i);
          let previousClusterIndex = clusterIndices[$_get](i);
          let previousCluster = clusters[$_get](previousClusterIndex);
          let previousDistance = pointProvider.distance(point, previousCluster);
          let minimumDistance = previousDistance;
          let newClusterIndex = -1;
          for (let j = 0; j < clusterCount; j = j + 1) {
            if (distanceToIndexMatrix[$_get](previousClusterIndex)[$_get](j).distance >= 4 * previousDistance) {
              continue;
            }
            let distance = pointProvider.distance(point, clusters[$_get](j));
            if (distance < minimumDistance) {
              minimumDistance = distance;
              newClusterIndex = j;
            }
          }
          if (newClusterIndex !== -1) {
            pointsMoved = pointsMoved + 1;
            clusterIndices[$_set](i, newClusterIndex);
          }
        }
        if (pointsMoved === 0 && iteration > 0) {
          quantizer_wsmeans.QuantizerWsmeans.debugLog("terminated after " + dart.strSafe(iteration) + " k-means iterations");
          break;
        }
        quantizer_wsmeans.QuantizerWsmeans.debugLog("iteration " + dart.strSafe(iteration + 1) + " moved " + dart.strSafe(pointsMoved));
        let componentASums = G.ListOfdouble().filled(clusterCount, 0.0);
        let componentBSums = G.ListOfdouble().filled(clusterCount, 0.0);
        let componentCSums = G.ListOfdouble().filled(clusterCount, 0.0);
        for (let i = 0; i < clusterCount; i = i + 1) {
          pixelCountSums[$_set](i, 0);
        }
        for (let i = 0; i < pointCount; i = i + 1) {
          let clusterIndex = clusterIndices[$_get](i);
          let point = points[$_get](i);
          let count = counts[$_get](i);
          pixelCountSums[$_set](clusterIndex, pixelCountSums[$_get](clusterIndex) + count);
          componentASums[$_set](clusterIndex, componentASums[$_get](clusterIndex) + point[$_get](0) * count);
          componentBSums[$_set](clusterIndex, componentBSums[$_get](clusterIndex) + point[$_get](1) * count);
          componentCSums[$_set](clusterIndex, componentCSums[$_get](clusterIndex) + point[$_get](2) * count);
        }
        for (let i = 0; i < clusterCount; i = i + 1) {
          let count = pixelCountSums[$_get](i);
          if (count === 0) {
            clusters[$_set](i, G.JSArrayOfdouble().of([0.0, 0.0, 0.0]));
            continue;
          }
          let a = componentASums[$_get](i) / count;
          let b = componentBSums[$_get](i) / count;
          let c = componentCSums[$_get](i) / count;
          clusters[$_set](i, G.JSArrayOfdouble().of([a, b, c]));
        }
      }
      let clusterArgbs = G.JSArrayOfint().of([]);
      let clusterPopulations = G.JSArrayOfint().of([]);
      for (let i = 0; i < clusterCount; i = i + 1) {
        let count = pixelCountSums[$_get](i);
        if (count === 0) {
          continue;
        }
        let possibleNewCluster = pointProvider.toInt(clusters[$_get](i));
        if (clusterArgbs[$contains](possibleNewCluster)) {
          continue;
        }
        clusterArgbs[$add](possibleNewCluster);
        clusterPopulations[$add](count);
      }
      quantizer_wsmeans.QuantizerWsmeans.debugLog("kmeans finished and generated " + dart.strSafe(clusterArgbs[$length]) + " clusters; " + dart.strSafe(clusterCount) + " were requested");
      let inputPixelToClusterPixel = new (G.IdentityMapOfint$int()).new();
      if (returnInputPixelToClusterPixel) {
        let stopwatch = (t$360 = new core.Stopwatch.new(), (() => {
          t$360.start();
          return t$360;
        })());
        for (let i = 0; i < pixels[$length]; i = i + 1) {
          let inputPixel = pixels[$_get](i);
          let clusterIndex = clusterIndices[$_get](i);
          let cluster = clusters[$_get](clusterIndex);
          let clusterPixel = pointProvider.toInt(cluster);
          inputPixelToClusterPixel[$_set](inputPixel, clusterPixel);
        }
        quantizer_wsmeans.QuantizerWsmeans.debugLog("took " + dart.strSafe(stopwatch.elapsedMilliseconds) + " ms to create input to cluster map");
      }
      return new quantizer.QuantizerResult.new(G.LinkedHashMapOfint$int().fromIterables(clusterArgbs, clusterPopulations), {inputPixelToClusterPixel: inputPixelToClusterPixel});
    }
    static ['_#new#tearOff']() {
      return new quantizer_wsmeans.QuantizerWsmeans.new();
    }
  };
  (quantizer_wsmeans.QuantizerWsmeans.new = function() {
    ;
  }).prototype = quantizer_wsmeans.QuantizerWsmeans.prototype;
  dart.addTypeTests(quantizer_wsmeans.QuantizerWsmeans);
  dart.addRtiResources(quantizer_wsmeans.QuantizerWsmeans, ["material_color_utilities__quantize__quantizer_wsmeans|QuantizerWsmeans"]);
  dart.addTypeCaches(quantizer_wsmeans.QuantizerWsmeans);
  dart.setStaticMethodSignature(quantizer_wsmeans.QuantizerWsmeans, () => ['debugLog', 'quantize']);
  dart.setLibraryUri(quantizer_wsmeans.QuantizerWsmeans, I[0]);
  dart.setStaticFieldSignature(quantizer_wsmeans.QuantizerWsmeans, () => ['debug']);
  dart.defineLazy(quantizer_wsmeans.QuantizerWsmeans, {
    /*quantizer_wsmeans.QuantizerWsmeans.debug*/get debug() {
      return false;
    }
  }, false);
  dart.moduleConstCaches.set("packages/material_color_utilities/quantize/quantizer_wsmeans.dart", C);
  dart_rti._Universe.addRules(dart.typeUniverse, JSON.parse('{"material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex":{"Comparable.T":"material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex","core|Comparable":["material_color_utilities__quantize__quantizer_wsmeans|DistanceAndIndex"]},"core|Comparable":{"Comparable.T":"1"},"core|int":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|num":{"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|double":{"core|num":[],"Comparable.T":"core|num","core|Comparable":["core|num"]},"core|List":{"List.E":"1","Iterable.E":"1","core|Iterable":["1"],"_ListIterable.E":"1","core|_ListIterable":["1"],"EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"]},"core|Iterable":{"Iterable.E":"1"},"core|_ListIterable":{"_ListIterable.E":"1","EfficientLengthIterable.T":"1","_internal|EfficientLengthIterable":["1"],"HideEfficientLengthIterable.T":"1","_internal|HideEfficientLengthIterable":["1"],"Iterable.E":"1","core|Iterable":["1"]},"_internal|EfficientLengthIterable":{"EfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"_internal|HideEfficientLengthIterable":{"HideEfficientLengthIterable.T":"1","Iterable.E":"1","core|Iterable":["1"]},"core|String":{"Comparable.T":"core|String","core|Comparable":["core|String"],"core|Pattern":[]}}'));
  dart.trackLibraries("packages/material_color_utilities/quantize/quantizer_wsmeans.dart", {
    "package:material_color_utilities/quantize/quantizer_wsmeans.dart": quantizer_wsmeans
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["quantizer_wsmeans.dart"],"names":[],"mappings":"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","file":"../../../../../../../../../../../../F:/packages/material_color_utilities/quantize/quantizer_wsmeans.dart.lib.js"}');
  // Exports:
  return {
    quantize__quantizer_wsmeans: quantizer_wsmeans
  };
}));

//# sourceMappingURL=quantizer_wsmeans.dart.lib.js.map
